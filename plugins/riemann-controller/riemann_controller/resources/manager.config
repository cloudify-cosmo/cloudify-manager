;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: Imports
;;

(ns riemann.config
  (:import [java.util HashMap])
  (:require riemann.core
            [clojure.java.io :as io]))

;;
;; End Section: Imports
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: Global riemann configuration
;;

(logging/init {:file "riemann.log"})

;;
;; End Section: Global riemann configuration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: User definitions
;; Mostly helper predicates, streams, etc... used
;; when writing policies
;;

; example: (where* (is-node-name "some_name") ...)
(defn is-node-name [node-name]
  (fn [event]
    (= node-name (:node_name event))))

;;
;; End Section: User definitions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: Deployments core administration
;;

(def config-lock              (Object.))
(def current-port             (atom 5556))
(def cores-map                (HashMap.))
(def port-file-name           "port")
(def managed-config-file-name "managed.config")

(defn start-config! [& children]
  (fn [event]
    (locking config-lock
      (let [tcp-port            @current-port
            config-path         (:description event)
            managed-config      (list 'tcp-server {:host "0.0.0.0" :port tcp-port})
            port-path           (str config-path "/" port-file-name)
            managed-config-path (str config-path "/" managed-config-file-name)]

        ; prepare config cores
        (reset! core      (riemann.core/core))
        (reset! next-core (riemann.core/core))

        ; write managed configuration and port to files
        (spit managed-config-path (str managed-config))
        (spit port-path           (str tcp-port))

        ; prepare new port for next request
        (swap! current-port inc)

        ; load configuration files and apply to create new core
        (try
          (include config-path)
          (apply!)
          (catch Exception e
            ; remove managed configuration and port files
            (io/delete-file port-path)
            (io/delete-file managed-config-path)
            (throw e)))

        ; store created core in a map a [key:config-path ==> value:core]
        (.put cores-map config-path @core)))))

(defn stop-config! [& children]
  (fn [event]
    (locking config-lock
      (let [config-path         (:description event)
            port-path           (str config-path "/" port-file-name)
            managed-config-path (str config-path "/" managed-config-file-name)
            ; get core instance to stop and remove it from the map
            stopped-core        (.remove cores-map config-path)]

        (when stopped-core
          ; remove managed configuration and port files
          (io/delete-file port-path)
          (io/delete-file managed-config-path)

          ; stop the core instance
          (riemann.core/stop! stopped-core))))))

;;
;; End Section: Deployments core administration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Section: Management core configuration
;;

(tcp-server {:host "0.0.0.0" :port 5555})

(periodically-expire 5)

(let [index (index)]
  (streams
    (default :ttl 60 index)
    (where (and (service "cloudify.configuration")
                (state "start"))
      (start-config!))
    (where (and (service "cloudify.configuration")
                (state "stop"))
      (stop-config!))))

;;
;; End Section: Management core configuration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
